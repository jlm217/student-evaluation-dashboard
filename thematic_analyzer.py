#!/usr/bin/env python3
"""
Thematic Analysis Agent - Phase 2

This script performs thematic synthesis on initial codes generated by the qualitative
coding agent. It processes coded CSV files and generates themes using Google's Gemini API,
producing comprehensive reports and a fully themed dataset.
"""

import os
import json
import pandas as pd
import google.generativeai as genai
from dotenv import load_dotenv
from typing import List, Dict, Any, Optional

# Constants
DEFAULT_CODED_FILE = "SAMPLEComments_coded.csv"

def load_config() -> bool:
    """
    Load environment variables and configure the Gemini client.
    
    Returns:
        bool: True if configuration is successful, False otherwise
    """
    try:
        # Load environment variables from .env file
        load_dotenv()
        
        # Get API key from environment
        api_key = os.getenv('GEMINI_API_KEY')
        if not api_key:
            print("Error: GEMINI_API_KEY not found in environment variables.")
            print("Please create a .env file with your API key:")
            print("GEMINI_API_KEY='your_api_key_here'")
            return False
        
        # Configure Gemini client
        genai.configure(api_key=api_key)
        print("✓ Gemini API configured successfully")
        return True
        
    except Exception as e:
        print(f"Error loading configuration: {e}")
        return False

def load_coded_csv(file_path: str) -> Optional[pd.DataFrame]:
    """
    Load the coded CSV file and validate required columns.
    
    Args:
        file_path (str): Path to the coded CSV file
        
    Returns:
        pd.DataFrame or None: Loaded DataFrame or None if error
    """
    try:
        # Load CSV file
        df = pd.read_csv(file_path)
        print(f"✓ Loaded coded CSV file: {file_path}")
        print(f"  Rows: {len(df)}, Columns: {len(df.columns)}")
        
        # Validate required columns
        required_cols = ['Initial_Code']
        missing_cols = [col for col in required_cols if col not in df.columns]
        
        if missing_cols:
            print(f"Error: Required columns missing: {missing_cols}")
            print(f"Available columns: {list(df.columns)}")
            return None
        
        # Remove rows with missing codes
        initial_rows = len(df)
        df = df.dropna(subset=['Initial_Code'])
        final_rows = len(df)
        
        if initial_rows > final_rows:
            print(f"  Removed {initial_rows - final_rows} rows with missing codes")
        
        print(f"✓ Validated required columns")
        return df
        
    except Exception as e:
        print(f"Error loading coded CSV file: {e}")
        return None

def extract_unique_codes(df: pd.DataFrame) -> List[str]:
    """
    Extract unique initial codes from the DataFrame.
    
    Args:
        df (pd.DataFrame): Coded DataFrame
        
    Returns:
        List[str]: List of unique initial codes
    """
    unique_codes = df['Initial_Code'].dropna().unique().tolist()
    print(f"✓ Extracted {len(unique_codes)} unique initial codes")
    return unique_codes

def create_thematic_prompt(codes_list: List[str]) -> str:
    """
    Create the thematic synthesis prompt with the provided codes.
    
    Args:
        codes_list (List[str]): List of initial codes to analyze
        
    Returns:
        str: Complete prompt for thematic analysis
    """
    prompt_template = """Role: You are a senior qualitative researcher specializing in grounded theory. You have been given a list of initial "open codes" derived from student feedback about a course.

Task: Your task is to perform axial coding. You must analyze the provided list of initial codes to identify patterns, connections, and relationships. Group related codes together to synthesize a concise set of 7-10 overarching themes.

Instructions:

    Review Holistically: Analyze the entire list of codes to understand the full scope of student feedback.

    Identify Core Themes: Group the initial codes into distinct, high-level themes. A theme should represent a major concept or area of concern/praise.

    Name and Describe: For each theme, provide a clear and concise theme_name and a one-sentence theme_description that explains the central idea of that theme.

    Show Your Work: For each theme you create, list the exact initial codes from the provided data that you grouped together to form that theme. This is crucial for maintaining a clear audit trail.

    Format: Return your entire analysis as a single JSON object. The object should contain one key, "themes", which is a list. Each item in the list represents a theme and must have the keys: theme_name, theme_description, and supporting_codes (a list of strings).

Example of Desired Output Structure:

{
  "themes": [
    {
      "theme_name": "Instructor Engagement and Presence",
      "theme_description": "Concerns the students' perception of the instructor's involvement, accessibility, and feedback quality.",
      "supporting_codes": [
        "Lack of Instructor Feedback/Support",
        "Instructor not present in videos",
        "Slow response to student inquiries",
        "Positive instructor interaction"
      ]
    },
    {
      "theme_name": "Course Material and Platform Issues",
      "theme_description": "Feedback related to the effectiveness and accuracy of textbooks, online platforms, and other learning materials.",
      "supporting_codes": [
        "Smartbooks not adequate measure",
        "Inaccurate time estimates",
        "Helpful online resources"
      ]
    }
  ]
}

Data for Analysis:

Here is the list of initial codes generated from the student feedback. Please synthesize them into a set of themes.

""" + json.dumps(codes_list, indent=2) + """

Return your analysis as a JSON object:

```json"""
    
    return prompt_template

def generate_themes(codes_list: List[str]) -> Optional[Dict[str, Any]]:
    """
    Generate themes from the list of initial codes using Gemini API.
    
    Args:
        codes_list (List[str]): List of initial codes to analyze
        
    Returns:
        Dict[str, Any] or None: Themes data or None if error
    """
    try:
        print(f"Generating themes from {len(codes_list)} initial codes...")
        
        # Create the prompt
        prompt = create_thematic_prompt(codes_list)
        
        # Call Gemini API
        model = genai.GenerativeModel('gemini-1.5-flash')
        response = model.generate_content(prompt)
        
        # Parse JSON response
        response_text = response.text.strip()
        
        # Clean up response text (remove markdown code blocks if present)
        if response_text.startswith('```json'):
            response_text = response_text[7:]
        if response_text.endswith('```'):
            response_text = response_text[:-3]
        response_text = response_text.strip()
        
        # Parse JSON
        themes_data = json.loads(response_text)
        
        print(f"✓ Generated {len(themes_data.get('themes', []))} themes")
        return themes_data
        
    except json.JSONDecodeError as e:
        print(f"Error parsing JSON response: {e}")
        print(f"Response text: {response_text}")
        return None
    except Exception as e:
        print(f"Error generating themes: {e}")
        return None

def write_markdown_report(themes_data: Dict[str, Any], output_path: str = "themes_report.md") -> bool:
    """
    Write a markdown report of the themes analysis.
    
    Args:
        themes_data (Dict[str, Any]): Themes data from API
        output_path (str): Path for the markdown report
        
    Returns:
        bool: True if successful, False otherwise
    """
    try:
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write("# Thematic Analysis Report\n\n")
            f.write("## Overview\n\n")
            
            themes = themes_data.get('themes', [])
            f.write(f"This report presents the results of thematic analysis performed on qualitative codes. ")
            f.write(f"A total of {len(themes)} themes were identified through axial coding.\n\n")
            
            f.write("## Themes\n\n")
            
            for i, theme in enumerate(themes, 1):
                theme_name = theme.get('theme_name', f'Theme {i}')
                theme_description = theme.get('theme_description', 'No description provided')
                supporting_codes = theme.get('supporting_codes', [])
                
                f.write(f"### {i}. {theme_name}\n\n")
                f.write(f"**Description:** {theme_description}\n\n")
                f.write(f"**Supporting Codes ({len(supporting_codes)}):**\n\n")
                
                for code in supporting_codes:
                    f.write(f"- {code}\n")
                
                f.write("\n---\n\n")
        
        print(f"✓ Markdown report saved to: {output_path}")
        return True
        
    except Exception as e:
        print(f"Error writing markdown report: {e}")
        return False

def write_csv_summary(themes_data: Dict[str, Any], output_path: str = "themes_summary.csv") -> bool:
    """
    Write a CSV summary of themes with names and descriptions.
    
    Args:
        themes_data (Dict[str, Any]): Themes data from API
        output_path (str): Path for the CSV summary
        
    Returns:
        bool: True if successful, False otherwise
    """
    try:
        themes = themes_data.get('themes', [])
        
        # Create summary DataFrame
        summary_data = []
        for theme in themes:
            summary_data.append({
                'Theme_Name': theme.get('theme_name', ''),
                'Theme_Description': theme.get('theme_description', ''),
                'Supporting_Codes_Count': len(theme.get('supporting_codes', []))
            })
        
        summary_df = pd.DataFrame(summary_data)
        summary_df.to_csv(output_path, index=False)
        
        print(f"✓ CSV summary saved to: {output_path}")
        return True
        
    except Exception as e:
        print(f"Error writing CSV summary: {e}")
        return False

def create_themed_csv(original_df: pd.DataFrame, themes_data: Dict[str, Any], input_file_path: str) -> bool:
    """
    Create a CSV file with theme assignments for each row.
    
    Args:
        original_df (pd.DataFrame): Original coded DataFrame
        themes_data (Dict[str, Any]): Themes data from API
        input_file_path (str): Path to input file for naming output
        
    Returns:
        bool: True if successful, False otherwise
    """
    try:
        # Create code-to-theme mapping
        code_to_theme = {}
        themes = themes_data.get('themes', [])
        
        for theme in themes:
            theme_name = theme.get('theme_name', '')
            supporting_codes = theme.get('supporting_codes', [])
            
            for code in supporting_codes:
                code_to_theme[code] = theme_name
        
        # Create themed DataFrame
        themed_df = original_df.copy()
        themed_df['Theme'] = themed_df['Initial_Code'].map(code_to_theme)
        
        # Handle unmapped codes
        unmapped_count = themed_df['Theme'].isna().sum()
        if unmapped_count > 0:
            print(f"Warning: {unmapped_count} codes could not be mapped to themes")
            themed_df['Theme'] = themed_df['Theme'].fillna('Unmapped')
        
        # Aggressively clean text fields to prevent CSV parsing issues
        text_columns = ['question', 'response', 'Initial_Code', 'Theme']
        for col in text_columns:
            if col in themed_df.columns:
                # Convert to string first
                themed_df[col] = themed_df[col].astype(str)
                # Remove ALL types of line breaks and control characters
                themed_df[col] = themed_df[col].str.replace('\n', ' ', regex=False)
                themed_df[col] = themed_df[col].str.replace('\r', ' ', regex=False)
                themed_df[col] = themed_df[col].str.replace('\t', ' ', regex=False)
                # Replace double quotes with single quotes to prevent quote conflicts
                themed_df[col] = themed_df[col].str.replace('"', "'", regex=False)
                # Remove any control characters that could break CSV parsing
                themed_df[col] = themed_df[col].str.replace(r'[\x00-\x1f\x7f-\x9f]', ' ', regex=True)
                # Consolidate multiple spaces to single space
                themed_df[col] = themed_df[col].str.replace(r'\s+', ' ', regex=True)
                # Strip leading/trailing whitespace
                themed_df[col] = themed_df[col].str.strip()
                # Cap extremely long text that could cause issues
                themed_df[col] = themed_df[col].str.slice(0, 8000)
        
        # Generate output filename
        base_name = os.path.splitext(input_file_path)[0]
        output_path = f"{base_name}_themed.csv"
        
        # Save CSV with the most robust settings possible
        themed_df.to_csv(
            output_path, 
            index=False, 
            quoting=1,              # QUOTE_ALL - quote every single field
            doublequote=True,       # Handle any remaining quotes correctly
            lineterminator='\n',    # Consistent line endings
            encoding='utf-8',       # Proper encoding
            escapechar=None         # Don't use escape characters
        )
        
        print(f"✓ Themed CSV saved to: {output_path}")
        return True
        
    except Exception as e:
        print(f"Error creating themed CSV: {e}")
        return False

def create_themed_dataframe(original_df: pd.DataFrame, themes_data: Dict[str, Any]) -> pd.DataFrame:
    """
    Create a DataFrame with theme assignments for each row.
    
    Args:
        original_df (pd.DataFrame): Original coded DataFrame
        themes_data (Dict[str, Any]): Themes data from API
        
    Returns:
        pd.DataFrame: DataFrame with Theme column added
    """
    # Create code-to-theme mapping
    code_to_theme = {}
    themes = themes_data.get('themes', [])
    
    for theme in themes:
        theme_name = theme.get('theme_name', '')
        supporting_codes = theme.get('supporting_codes', [])
        
        for code in supporting_codes:
            code_to_theme[code] = theme_name
    
    # Create themed DataFrame
    themed_df = original_df.copy()
    themed_df['Theme'] = themed_df['Initial_Code'].map(code_to_theme)
    
    # Handle unmapped codes
    unmapped_count = themed_df['Theme'].isna().sum()
    if unmapped_count > 0:
        print(f"Warning: {unmapped_count} codes could not be mapped to themes")
        themed_df['Theme'] = themed_df['Theme'].fillna('Unmapped')
    
    # Clean text fields for better JSON serialization
    text_columns = ['question', 'response', 'Initial_Code', 'Theme']
    for col in text_columns:
        if col in themed_df.columns:
            # Convert to string and clean
            themed_df[col] = themed_df[col].astype(str)
            themed_df[col] = themed_df[col].str.replace('\n', ' ', regex=False)
            themed_df[col] = themed_df[col].str.replace('\r', ' ', regex=False)
            themed_df[col] = themed_df[col].str.replace('\t', ' ', regex=False)
            themed_df[col] = themed_df[col].str.replace(r'\s+', ' ', regex=True)
            themed_df[col] = themed_df[col].str.strip()
            # Cap extremely long text
            themed_df[col] = themed_df[col].str.slice(0, 8000)
    
    return themed_df


def generate_markdown_report(themes_data: Dict[str, Any]) -> str:
    """
    Generate a markdown report string from themes data.
    
    Args:
        themes_data (Dict[str, Any]): Themes data from API
        
    Returns:
        str: Markdown report as string
    """
    report_lines = []
    report_lines.append("# Thematic Analysis Report\n")
    report_lines.append("## Overview\n")
    
    themes = themes_data.get('themes', [])
    report_lines.append(f"This report presents the results of thematic analysis performed on qualitative codes. ")
    report_lines.append(f"A total of {len(themes)} themes were identified through axial coding.\n")
    
    report_lines.append("## Themes\n")
    
    for i, theme in enumerate(themes, 1):
        theme_name = theme.get('theme_name', f'Theme {i}')
        theme_description = theme.get('theme_description', 'No description provided')
        supporting_codes = theme.get('supporting_codes', [])
        
        report_lines.append(f"### {i}. {theme_name}\n")
        report_lines.append(f"**Description:** {theme_description}\n")
        report_lines.append(f"**Supporting Codes ({len(supporting_codes)}):**\n")
        
        for code in supporting_codes:
            report_lines.append(f"- {code}")
        
        report_lines.append("\n---\n")
    
    return '\n'.join(report_lines)


def analyze_themes(coded_df: pd.DataFrame, input_file_path: str = None) -> tuple[pd.DataFrame, str]:
    """
    Perform thematic analysis on coded qualitative data.
    
    Args:
        coded_df (pd.DataFrame): DataFrame with coded data
        input_file_path (str, optional): Original file path for naming outputs (backward compatibility)
        
    Returns:
        tuple[pd.DataFrame, str]: (themed_dataframe, markdown_report)
    """
    print("=== Thematic Analysis Agent - Phase 2 ===\n")
    
    # Load configuration
    if not load_config():
        raise Exception("Failed to load API configuration")
    
    # Validate the DataFrame
    if coded_df is None or coded_df.empty:
        raise ValueError("Input DataFrame is empty or None")
    
    if 'Initial_Code' not in coded_df.columns:
        raise ValueError("DataFrame must contain 'Initial_Code' column")
    
    # Remove rows with missing codes
    initial_rows = len(coded_df)
    df = coded_df.dropna(subset=['Initial_Code']).copy()
    final_rows = len(df)
    
    if initial_rows > final_rows:
        print(f"Removed {initial_rows - final_rows} rows with missing codes")
    
    # Extract unique initial codes
    codes_list = extract_unique_codes(df)
    if not codes_list:
        print("No codes found for thematic analysis")
        # Return original DataFrame with empty Theme column and basic report
        df['Theme'] = 'No themes generated'
        report = "# Thematic Analysis Report\n\nNo codes found for analysis."
        return df, report
    
    # Generate themes via API
    print(f"Starting thematic synthesis...")
    themes_data = generate_themes(codes_list)
    if themes_data is None:
        print("Failed to generate themes")
        df['Theme'] = 'Theme generation failed'
        report = "# Thematic Analysis Report\n\nTheme generation failed."
        return df, report
    
    # Create themed DataFrame
    themed_df = create_themed_dataframe(df, themes_data)
    
    # Generate markdown report
    markdown_report = generate_markdown_report(themes_data)
    
    print(f"=== Thematic Analysis Complete ===")
    print(f"Total rows processed: {len(themed_df)}")
    print(f"Unique codes analyzed: {len(codes_list)}")
    print(f"Themes generated: {len(themes_data.get('themes', []))}")
    
    # Show generated themes
    themes = themes_data.get('themes', [])
    if themes:
        print(f"Generated Themes:")
        for i, theme in enumerate(themes, 1):
            theme_name = theme.get('theme_name', f'Theme {i}')
            supporting_count = len(theme.get('supporting_codes', []))
            print(f"  {i}. {theme_name} ({supporting_count} supporting codes)")
    
    # Save outputs if file path provided (for backward compatibility)
    if input_file_path:
        write_markdown_report(themes_data, "themes_report.md")
        write_csv_summary(themes_data, "themes_summary.csv")
        create_themed_csv(themed_df, themes_data, input_file_path)
    
    return themed_df, markdown_report


def analyze_themes_legacy(input_file: str) -> List[str]:
    """
    Legacy function for backward compatibility.
    
    Args:
        input_file (str): Path to the coded CSV file
        
    Returns:
        List[str]: List of output file paths generated
    """
    output_files = []
    
    if not os.path.exists(input_file):
        raise FileNotFoundError(f"File '{input_file}' not found")
    
    # Load coded CSV data
    df = load_coded_csv(input_file)
    if df is None:
        raise Exception("Failed to load coded CSV data")
    
    try:
        themed_df, markdown_report = analyze_themes(df, input_file)
        
        # Files were saved by analyze_themes since we provided input_file_path
        output_files.append("themes_report.md")
        output_files.append("themes_summary.csv")
        
        base_name = os.path.splitext(input_file)[0]
        themed_path = f"{base_name}_themed.csv"
        output_files.append(themed_path)
        
        return output_files
        
    except Exception as e:
        print(f"Legacy analysis failed: {e}")
        raise


def main():
    """
    Main function to orchestrate the thematic analysis process.
    """
    print("=== Thematic Analysis Agent - Phase 2 ===\n")
    
    # Load configuration
    if not load_config():
        return
    
    # Get input file path from user
    input_file = input(f"Enter the path to your coded CSV file (default: '{DEFAULT_CODED_FILE}'): ").strip()
    if not input_file:
        input_file = DEFAULT_CODED_FILE
        
    if not os.path.exists(input_file):
        print(f"Error: File '{input_file}' not found.")
        return
    
    try:
        analyze_themes_legacy(input_file)
    except Exception as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    main() 